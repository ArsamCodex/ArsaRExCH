@using ArsaRExCH.Model
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Identity
@inject NavigationManager Navigation
@inject ArsaRExCH.Interface.ITrade _tradeInterface
@inject ArsaRExCH.Interface.AdministrationInterface _adminInterface
@inject ArsaRExCH.Interface.WalletInterface<double> _walletInterface
@rendermode InteractiveServer
@inject AuthenticationStateProvider _AuthenticationStateProvider
@using Microsoft.AspNetCore.Authorization
@using System.Security.Claims
@attribute [Authorize]
@implements IDisposable
<div style="display: flex; width: 100%;">
    <div style="flex: 0 0 70%; height: 400px;">
        <ArsaRExCH.Components.Chartss.TradingViewChart></ArsaRExCH.Components.Chartss.TradingViewChart>
    </div>
    
    <div id="additional-content" style="flex: 0 0 30%; height: 400px; background-color: white">
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>BTC</th>
                    <th>USDT</th>
                    <th>Date</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var trade in TradeListLast50)
                {
                    <tr>
                        <td>@trade.User?.Id?.ToString()?.Substring(Math.Max(0, trade.User.Id.Length - 5))</td>
                        <td>@trade.symbolI.ToString("F4")</td>
                        <td>@trade.SymbolII.ToString("F4")</td>
                        <td>@trade.dateTime</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
</div>

<h5><b>@tradeModel.TradePair</b></h5>
<div style="display: flex;">
    <div style="width: 20%; margin-right: 10px;">
        <EditForm EditContext="@editContext" OnValidSubmit="HandleValidSubmit">
            <DataAnnotationsValidator />
            <ValidationSummary />
            <div class="form-group">
                <label for="symbolI">BTC Amount</label>
                <InputNumber id="symbolI"
                             class="form-control"
                             @bind-Value="tradeModel.symbolI" />
            </div>
            <p>Available Balance to swap : @AvailableBtcAmountToSwap</p>
            <button type="submit" class="btn btn-primary">Submit</button>
        </EditForm>
    </div>

    <div style="width: 30%; background-color: white; border: 1px solid #ccc; border-radius: 5px; padding: 20px;height:200px">
        <p>BTC Price :@btcPriceVariable</p>
        <p>Last Updated: @lastUpdatedTime</p>
        <p>Btc To swap :@BtcToswapInclude</p>
        <p>To Get :@EstimatedUsdtToGetInCludeFee USDT </p>
        <p>Fee : @feeFromDbCall.ToString("F9")</p>
    </div>
</div>
<p>@ErrorMessage</p>

@code {
    private Trade tradeModel = new Trade();
    private EditContext editContext;
    public string ErrorMessage { get; set; }
    public string user2 { get; set; }
    public double feeFromDbCall { get; set; }
    public double EstimatedUsdtToGetInCludeFee { get; set; }
    private string btcPriceVariable;
    private string ethPriceVariable;
    public double BtcToswapInclude { get; set; }
    public double AvailableBtcAmountToSwap { get; set; }
    private List<Trade> TradeListLast50 { get; set; } = new List<Trade>();

    [CascadingParameter(Name = "EthPrice")]
    public string EthPrice { get; set; }

    [CascadingParameter(Name = "BtcPrice")]
    public string BtcPrice
    {
        get => btcPriceVariable;
        set
        {
            if (btcPriceVariable != value)
            {
                btcPriceVariable = value;
                UpdateTimestamp();
                FetchTradesAsync();
            }
        }
    }
    private async Task FetchTradesAsync()
    {
        try
        {
            var allTrades = await _tradeInterface.GetAllTrades();
            TradeListLast50 = allTrades.OrderByDescending(trade => trade.dateTime).Take(50).ToList();
            StateHasChanged(); // Request a UI update
        }
        catch (Exception ex)
        {
            TradeListLast50 = new List<Trade>(); // Ensure no null reference
            Console.WriteLine($"Error fetching trades: {ex.Message}"); // Debug log
        }
    }
    private string lastUpdatedTime;

    private void UpdateTimestamp()
    {
        lastUpdatedTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
        StateHasChanged(); // Trigger a UI update
    }
    protected override void OnParametersSet()
    {
        btcPriceVariable = BtcPrice;
        ethPriceVariable = EthPrice;
    }

    protected override async Task OnInitializedAsync()
    {
        editContext = new EditContext(tradeModel);
        editContext.OnFieldChanged += HandleFieldChanged;

        var authState = await _AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated ?? false)
        {
            user2 = user.FindFirst(u => u.Type.Contains("nameidentifier"))?.Value;
            tradeModel.TradePair = PairNames.BTCUSDT;
            AvailableBtcAmountToSwap = await _walletInterface.GetBTCBalanceOfWallet(user2);
            feeFromDbCall = await _tradeInterface.GetTradeFee();
        }
    }

    private async void HandleFieldChanged(object sender, FieldChangedEventArgs e)
    {
        if (e.FieldIdentifier.FieldName == nameof(tradeModel.symbolI))
        {
            // Update calculations or other logic based on the changed field
            //  BtcToswapInclude = tradeModel.symbolI - feeFromDbCall;
            await CalcuateUsdtGet();
        }
    }

    private async Task CalcuateUsdtGet()
    {
        var tt = ConvertStringToDouble(BtcPrice);
        var usdtBAck = tradeModel.symbolI * tt;
        EstimatedUsdtToGetInCludeFee = usdtBAck;
        BtcToswapInclude = tradeModel.symbolI - feeFromDbCall;
    }

    private async Task HandleValidSubmit()
    {
        if (tradeModel.symbolI > AvailableBtcAmountToSwap)
        {
            ErrorMessage = "Not Enough Balance Available";
            return;
        }

        var trade = new Trade
            {
                TradeId = Guid.NewGuid().ToString(),
                TradePair = PairNames.BTCUSDT,
                dateTime = DateTime.Now,
                symbolI = tradeModel.symbolI,
                SymbolII = EstimatedUsdtToGetInCludeFee,
                TradeFee = feeFromDbCall,//TODO edit echange wallet 
                IsMarketBuy = true,
                IsTradeDone = true,
                MyProperty = "sdsdsd",
                ApplicationUserId = user2,
                /*hardcode pool - A CALL TO DB NEED*/
                BitcoinPoolId = 1
            };

        try
        {
            await _tradeInterface.SaveTrade(trade);
            await _walletInterface.UpdateWalletsAfterTradeAsync(user2, tradeModel.symbolI, EstimatedUsdtToGetInCludeFee);
            string ExchangeUserid = "45dd7981-10da-437b-926a-65071f4da71b";
            await _adminInterface.EditBTCWalletExchangeAmountIncrease(ExchangeUserid, feeFromDbCall);
            ErrorMessage = "Trade added successfully!";
            tradeModel = new Trade();
            AvailableBtcAmountToSwap = await _walletInterface.GetBTCBalanceOfWallet(user2);
        }
        catch (Exception ex)
        {
            ErrorMessage = "An error occurred while saving the trade.";
        }
    }

  
    public double ConvertStringToDouble(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            Console.WriteLine("Input string is null or empty.");
            return 0;
        }

        double result;
        if (double.TryParse(input, out result))
        {
            return result;
        }
        else
        {
            Console.WriteLine($"Invalid format for double conversion: '{input}'");
            return 0;
        }
    }
    public void Dispose()
    {
        // Unsubscribe from the OnFieldChanged event
        if (editContext != null)
        {
            editContext.OnFieldChanged -= HandleFieldChanged;
        }
    }
}
