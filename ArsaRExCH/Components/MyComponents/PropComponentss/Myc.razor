@inject IJSRuntime JS
@implements IDisposable
@inject ArsaRExCH.Interface.PropInterface.IProp _prop
@using ArsaRExCH.Components.Account
@using ArsaRExCH.DTOs
@using ArsaRExCH.Interface
@using ArsaRExCH.Model.Prop
@rendermode InteractiveServer
@inject IHttpContextAccessor HttpContextAccessor
@inject IdentityUserAccessor UserAccessor
@using ArsaRExCH.Components.Chartss
@using Microsoft.AspNetCore.Authorization
@using Microsoft.EntityFrameworkCore
@using ArsaRExCH.Data
@inject IDbContextFactory<ApplicationDbContext> dbContextFactory
@inject NavigationManager _manager
@attribute [Authorize]


<div style="display: flex; gap: 20px; align-items: center; font-size: 16px; color: #333; font-family: Arial, sans-serif;">
    <p style="margin: 0; font-weight: bold;">Prop User Balance: <span style="font-weight: normal;background-color:greenyellow">@propUser.Balance</span></p>
    <p style="margin: 0; font-weight: bold;">Account Type: <span style="font-weight: normal;">@propUser.CurrentAccountType</span></p>
    <p style="margin: 0; font-weight: bold;">PropUserId: <span style="font-weight: normal;">@propUser.PropUserId</span></p>

</div>



<div style="display: flex; gap: 20px;">

    <!-- Chart Container -->
    <div style="width: 70%; height: 400px;">
        <ArsaRExCH.Components.Chartss.TradingViewChart pair="@Pair"></ArsaRExCH.Components.Chartss.TradingViewChart>
    </div>
    <!-- Sidebar for Progress Bar, Form, and Dropdowns -->
    <div style="display: flex; flex-direction: column; gap: 20px; width: 30%; border: 1px solid red; padding: 10px;">

        <!-- Progress Bar on Top -->
        <div style="flex: 1;">
            <div class="progress" style="height: 20px;">
                <div class="progress-bar" role="progressbar" style="width: @GetPercentage(Level)%;"
                     aria-valuenow="@Level" aria-valuemin="2" aria-valuemax="20">
                    @Level
                </div>
            </div>
        </div>

        <!-- Leverage Slider and Dropdowns Below Progress Bar -->
        <div style="display: flex; flex-direction: column; gap: 20px;">

            <!-- Leverage Control -->
            <div>
                <label for="levelSlider">Leverage (2-20):</label>
                <input type="range" id="levelSlider" min="2" max="20" @bind="Level" class="form-range" />
                <p>Chosen Leverage: @Level</p>
            </div>

            <!-- Order Type and Buy/Sell Selection -->
            <div style="display: flex; gap: 10px; justify-content: space-between;">
                <div>
                    <h5><b>Order Type</b></h5>
                    <select @bind="selectedTradeType" class="form-select">
                        <option value="Market">Market</option>
                        <option value="Order">Order</option>
                    </select>
                </div>
                <div>
                    <h5><b>Buy/Sell</b></h5>
                    <select @bind="selectedBuySel" class="form-select">
                        <option value="Buy">Buy</option>
                        <option value="Sell">Sell</option>
                    </select>
                </div>
            </div>
            <!-- Form for Amount, Take Profit, Stop Loss, and Submit Button -->
            <strong>@ErrorMessage</strong>
            <EditForm EditContext="@editContext" OnValidSubmit="HandleTradeBuyMarketButton">
                <DataAnnotationsValidator />
                <ValidationSummary />
                <div class="form-group" style="display: flex; gap: 20px; justify-content: space-between;">

                    <!-- Amount Field -->
                    <div style="flex: 1; display: flex; gap: 20px;">
                        @if (selectedBuySel == "Buy" && selectedTradeType == "Market")
                        {
                            <!-- Amount Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="symbolI">Amount</label>
                                <InputNumber id="symbolI"
                                             class="form-control"
                                             @bind-Value="propTrade.AmountForOrder" />
                            </div>

                            <!-- Take Profit Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="takeProfit">Take Profit</label>
                                <InputNumber id="takeProfit"
                                             class="form-control"
                                             @bind-Value="propTrade.TakeProfit" />
                            </div>

                            <!-- Stop Loss Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="stopLoss">Stop Loss</label>
                                <InputNumber id="stopLoss"
                                             class="form-control"
                                             @bind-Value="propTrade.StopLoss" />
                            </div>
                        }
                        @if (selectedBuySel == "Sell" && selectedTradeType == "Market")
                        {
                            <!-- Amount Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="symbolI">Amount</label>
                                <InputNumber id="symbolI"
                                             class="form-control"
                                             @bind-Value="propTrade.AmountForOrder" />
                            </div>

                            <!-- Take Profit Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="takeProfit">Take Profit</label>
                                <InputNumber id="takeProfit"
                                             class="form-control"
                                             @bind-Value="propTrade.TakeProfit" />
                            </div>

                            <!-- Stop Loss Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="stopLoss">Stop Loss</label>
                                <InputNumber id="stopLoss"
                                             class="form-control"
                                             @bind-Value="propTrade.StopLoss" />
                            </div>
                        }
                        @if (selectedBuySel == "Buy" && selectedTradeType == "Order")
                        {
                            <!-- Stop Loss Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="stopLoss">OrderP</label>
                                <InputNumber id="stopLoss"
                                             class="form-control"
                                             @bind-Value="propTrade.OrderPriceOpened" />

                            </div>
                            <!-- Amount Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="symbolI">Amount</label>
                                <InputNumber id="symbolI"
                                             class="form-control"
                                             @bind-Value="propTrade.AmountForOrder" />
                            </div>

                            <!-- Take Profit Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="takeProfit">Take Profit</label>
                                <InputNumber id="takeProfit"
                                             class="form-control"
                                             @bind-Value="propTrade.TakeProfit" />
                            </div>

                            <!-- Stop Loss Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="stopLoss">Stop Loss</label>
                                <InputNumber id="stopLoss"
                                             class="form-control"
                                             @bind-Value="propTrade.StopLoss" />

                            </div>

                        }
                        @if (selectedBuySel == "Sell" && selectedTradeType == "Order")
                        {
                            <!-- Stop Loss Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="stopLoss">OrderP</label>
                                <InputNumber id="stopLoss"
                                             class="form-control"
                                             @bind-Value="propTrade.OrderPriceOpened" />

                            </div>
                            <!-- Amount Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="symbolI">Amount</label>
                                <InputNumber id="symbolI"
                                             class="form-control"
                                             @bind-Value="propTrade.AmountForOrder" />
                            </div>

                            <!-- Take Profit Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="takeProfit">Take Profit</label>
                                <InputNumber id="takeProfit"
                                             class="form-control"
                                             @bind-Value="propTrade.TakeProfit" />
                            </div>

                            <!-- Stop Loss Field -->
                            <div style="flex: 1; width: 25%;">
                                <label for="stopLoss">Stop Loss</label>
                                <InputNumber id="stopLoss"
                                             class="form-control"
                                             @bind-Value="propTrade.StopLoss" />

                            </div>

                        }
                    </div>
                </div>

                <button type="submit" class="btn btn-primary">Place Order</button>
            </EditForm>



        </div>
    </div>
</div>
<div style="display: flex; gap: 20px;">

    <div style="width: 100%; height: 400px">
        @if (OrderTradeList == null)
        {
            <p><em>Loading...</em></p>
        }
        else if (OrderTradeList.Count == 0)
        {
            <p>No prop trades found.</p>
        }
        else
        {
            <table class="table table-bordered" style="box-shadow: 0px 4px 8px rgba(4, 6, 4, 0.3);">
                <thead>
                    <tr>
                        <th>Order Price </th>
                        <th>Trigered </th>
                        <th>SL</th>
                        <th>TP</th>
                        <th>Amount </th>
                        <th>Lev</th>
                        <th>Liquidation</th>
                        <th>Date</th>
                        <th>Type</th>
                        <th>Margin</th>
                        <th>Profit</th>
                        <th>Quantity</th>
                        <th>Status</th>
                        <th>Type</th>
                        <th>Action</th>

                    </tr>
                </thead>
                <tbody>
                    @foreach (var trade in OrderTradeList)
                    {
                        <tr>
                            <td style="width:8%"><strong style="background-color:aliceblue">@trade.OrderPriceOpened.ToString("C2", System.Globalization.CultureInfo.GetCultureInfo("en-US"))</strong></td>
                            <td style="width:8%">@trade.OrderPriceTriggerd?.ToString("C2", System.Globalization.CultureInfo.GetCultureInfo("en-US"))</td>

                            <td style="width:6%">@(trade.StopLoss?.ToString("C2", System.Globalization.CultureInfo.GetCultureInfo("en-US")) ?? "N/A")</td>
                            <td style="width:6%">@(trade.TakeProfit?.ToString("C2", System.Globalization.CultureInfo.GetCultureInfo("en-US")) ?? "N/A")</td>

                            <td style="width:6%">@trade.AmountForOrder.ToString("C2", System.Globalization.CultureInfo.GetCultureInfo("en-US"))</td>
                            <td style="width:4%">X @trade.Leverage</td>
                            <td style="width:6%">@trade.LiquidationPrice.ToString("0.###")</td>
                            <td style="width:8%">@trade.TradeOpened.ToString("yyyy-MM-dd HH:mm:ss")</td>
                            <td style="width:6%; background-color:@(trade.orderTypeProp == OrderTypeProp.Buy ? "lightgreen" : "red")">
                                @trade.orderTypeProp
                            </td>

                            <td style="width:8%">@((trade.Leverage * trade.AmountForOrder).ToString("C2", System.Globalization.CultureInfo.GetCultureInfo("en-US"))) </td>

                            <td style="width:8%">

                                @{
                                    var profitLoss = CalculateProfitLossInDollar(
                                    trade.OrderPriceOpened,
                                    decimal.TryParse(btcPriceVariable, out var parsedPrice) ? parsedPrice : 0m,
                                    trade.AmountForOrder,
                                    trade.Leverage,
                                    trade.orderTypeProp,
                                    trade.MarketType,
                                    trade.Status
                                    );
                                    var backgroundColor = profitLoss >= 0 ? "green" : "red";
                                }
                                <span style="font-weight: normal; background-color: @backgroundColor; color: white;">
                                    @profitLoss.ToString("0.###")
                                </span>
                            </td>
                            <td style="width:2%"> @((trade.Leverage * trade.AmountForOrder / trade.OrderPriceOpened).ToString("0.#####"))</td>
                            <td style="width:2%"> @trade.Status</td>

                            <td style="width:5%">@trade.MarketType</td>

                            <td>
                                <button @onclick="() => CloseMarketOrder(trade.PropTradeId)"
                                        style="background-color: yellow; color: black; border: none; padding: 8px 16px; cursor: pointer;"
                                        onmouseover="this.style.backgroundColor='lightblue'; this.style.color='white';"
                                        onmouseout="this.style.backgroundColor='yellow'; this.style.color='black';">
                                    Close
                                </button>


                                <button @onclick="() => ShowEditSPLForm()" style="background-color: lightcoral; color: black; border: none; padding: 8px 16px; cursor: pointer;"
                                        onmouseover="this.style.backgroundColor='red'; this.style.color='white';"
                                        onmouseout="this.style.backgroundColor='lightcoral'; this.style.color='black';">
                                    Edit SP/TP
                                </button>
                            </td>

                        </tr>
                        @if (EditSLTP)
                        {
                            <div class="modal-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; z-index: 1000; background-color: rgba(0, 0, 0, 0.6); pointer-events: none;">
                                <div class="modal-dialog" style="max-width: 1000px; background: #fff; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); pointer-events: auto;">
                                    <p>Edit Trade : </p>
                                    <div class="modal-body" style="padding: 20px; color: #555;">
                                        <EditForm EditContext="@editContext" OnValidSubmit="() => EditStopLossTakeProfitButton(trade.PropTradeId)">
                                            <DataAnnotationsValidator />
                                            <ValidationSummary />

                                            <div style="flex: 1; display: flex; gap: 20px;">
                                                <!-- Amount Field -->
                                                <div style="flex: 1; width: 25%;">
                                                    <label for="symbolI">Stop Loss</label>
                                                    <InputNumber id="symbolI"
                                                                 class="form-control"
                                                                 @bind-Value="propTrade.StopLoss" />
                                                </div>

                                                <!-- Take Profit Field -->
                                                <div style="flex: 1; width: 25%;">
                                                    <label for="takeProfit">Take Profit</label>
                                                    <InputNumber id="takeProfit"
                                                                 class="form-control"
                                                                 @bind-Value="propTrade.TakeProfit" />
                                                </div>
                                            </div>


                                        </EditForm>
                                    </div>
                                    <div class="modal-footer" style="display: flex; justify-content: flex-start; padding-top: 10px;">
                                        <button type="button" class="btn btn-secondary" @onclick="Close" style="padding: 8px 16px; background-color: #e0e0e0; border: none; color: #333; border-radius: 4px; cursor: pointer;">Close</button>
                                        <button type="button" class="btn btn-secondary" @onclick="() => EditStopLossTakeProfitButton(trade.PropTradeId)" style="padding: 8px 16px; background-color: #e0e0e0; border: none; color: #333; border-radius: 4px; cursor: pointer;">Save</button>

                                    </div>
                                </div>
                            </div>


                        }

                    }

                </tbody>
            </table>


        }
    </div>
</div>



@ErrorMessage
<p>@Pair</p>
@code {
    [Parameter]
    public string HashFllag { get; set; }
    [Parameter]
    public string Pair { get; set; }
    private Timer _timer;
    private int Level { get; set; } = 2;
    private string selectedTradeType = "Market"; // Default selected value
    private List<PropTrade> OrderTradeList { get; set; } = new List<PropTrade>();
    private string selectedBuySel = "Sell";
    private EditContext editContext;
    private PropTrade propTrade = new PropTrade();
    public string? user2 { get; set; }
    public string? ErrorMessage { get; set; }
    public decimal LiquidationPrice { get; set; }
    public decimal TotalMargin { get; set; }
    public string btcPriceVariable { get; set; }
    public int PropUserId { get; set; }
    public PropUser propUser { get; set; } = new PropUser();
    public int userIdprop { get; set; }
    private bool EditSLTP { get; set; } = false;


    private async Task HandleTradeBuyMarketButton()
    {
        var btcDecimal = decimal.TryParse(btcPriceVariable, out var parsedPrice) ? parsedPrice : 0m;
        if (selectedTradeType == "Market" && selectedBuySel == "Buy")
        {
            //TODO here i need to validate
            if (propTrade.AmountForOrder <= 0)
            {
                ErrorMessage = "amount smaller then zero";
                return;
            }

            var newPropTrade = new PropTrade
                {
                    TradeOpened = DateTime.Now,
                    OrderPriceOpened = btcDecimal * 1.001m,
                    Leverage = Level,
                    AmountForOrder = propTrade.AmountForOrder,
                    Status = OrderStatus.Open,
                    ProfitInCase = 0,
                    MarketType = MarketType.Market,
                    FeeInCase = 0,
                    orderTypeProp = OrderTypeProp.Buy,
                    LiquidationPrice = CalculateLiquidationPrice(btcDecimal, Level, OrderTypeProp.Buy),
                    TakeProfit = propTrade.TakeProfit,
                    StopLoss = propTrade.StopLoss,
                    PropUserId = propUser.PropUserId,
                    PairName = Pair


                };

            // Use the context to add and save the new propTrade instance
            var context = dbContextFactory.CreateDbContext();

            var myT = await context.propUsers.Where(c => c.ApplicationUserId == user2)
              .FirstOrDefaultAsync();
            if (myT.Balance < propTrade.AmountForOrder)
            {
                ErrorMessage = "Not Allow Balance Greater";
                return;
            }
            myT.Balance -= propTrade.AmountForOrder;


            await context.propTrdaes.AddAsync(newPropTrade);
            await context.SaveChangesAsync();
            OrderTradeList = await ListOfOpenTrades();
            propUser = await GetPropUser(user2);

        }
        if (selectedTradeType == "Market" && selectedBuySel == "Sell")
        {
            if (propTrade.AmountForOrder <= 0)
            {
                ErrorMessage = "amount smaller then zero";
                return;
            }

            var newPropTrade = new PropTrade
                {
                    TradeOpened = DateTime.Now,
                    OrderPriceOpened = btcDecimal * 0.999m,
                    Leverage = Level,
                    AmountForOrder = propTrade.AmountForOrder,
                    Status = OrderStatus.Open,
                    ProfitInCase = 0,
                    MarketType = MarketType.Market,
                    FeeInCase = 0,
                    orderTypeProp = OrderTypeProp.Sell,
                    LiquidationPrice = CalculateLiquidationPrice(btcDecimal, Level, OrderTypeProp.Sell),
                    TakeProfit = propTrade.TakeProfit,
                    StopLoss = propTrade.StopLoss,
                    // Set the PropUserId if necessary
                    PropUserId = propUser.PropUserId,
                    PairName = Pair

                };

            // Use the context to add and save the new propTrade instance
            var context = dbContextFactory.CreateDbContext();

            var myT = await context.propUsers.Where(c => c.ApplicationUserId == user2)
              .FirstOrDefaultAsync();
            if (myT.Balance < propTrade.AmountForOrder)
            {
                ErrorMessage = "Not Allow Balance Greater";
                return;
            }
            myT.Balance -= propTrade.AmountForOrder;


            await context.propTrdaes.AddAsync(newPropTrade);
            await context.SaveChangesAsync();
            OrderTradeList = await ListOfOpenTrades();
            propUser = await GetPropUser(user2);

        }
        //TODO
        if (selectedTradeType == "Order" && selectedBuySel == "Buy")
        {
            if (propTrade.AmountForOrder <= 0)
            {
                ErrorMessage = "amount smaller then zero";
                return;
            }

            var newPropTrade = new PropTrade
                {
                    TradeOpened = DateTime.Now,

                    OrderPriceOpened = propTrade.OrderPriceOpened,
                    Leverage = Level,
                    AmountForOrder = propTrade.AmountForOrder,
                    Status = OrderStatus.Pending,
                    ProfitInCase = 0,
                    MarketType = MarketType.Order,
                    FeeInCase = 0,
                    orderTypeProp = OrderTypeProp.Buy,
                    LiquidationPrice = CalculateLiquidationPrice(btcDecimal, Level, OrderTypeProp.Buy),
                    TakeProfit = propTrade.TakeProfit,
                    StopLoss = propTrade.StopLoss,
                    PropUserId = propUser.PropUserId,
                    PairName = Pair

                };

            // Use the context to add and save the new propTrade instance
            var context = dbContextFactory.CreateDbContext();

            var myT = await context.propUsers.Where(c => c.ApplicationUserId == user2)
              .FirstOrDefaultAsync();
            if (myT.Balance < propTrade.AmountForOrder)
            {
                ErrorMessage = "Not Allow Balance Greater";
                return;
            }
            myT.Balance -= propTrade.AmountForOrder;


            await context.propTrdaes.AddAsync(newPropTrade);
            await context.SaveChangesAsync();
            OrderTradeList = await ListOfOpenTrades();
            propUser = await GetPropUser(user2);
        }
        if (selectedTradeType == "Order" && selectedBuySel == "Sell")
        {
            if (propTrade.AmountForOrder <= 0)
            {
                ErrorMessage = "amount smaller then zero";
                return;
            }

            var newPropTrade = new PropTrade
                {
                    TradeOpened = DateTime.Now,
                    OrderPriceOpened = propTrade.OrderPriceOpened,
                    Leverage = Level,
                    AmountForOrder = propTrade.AmountForOrder,
                    Status = OrderStatus.Pending,
                    ProfitInCase = 0,
                    MarketType = MarketType.Order,
                    FeeInCase = 0,
                    orderTypeProp = OrderTypeProp.Sell,
                    LiquidationPrice = CalculateLiquidationPrice(btcDecimal, Level, OrderTypeProp.Sell),
                    TakeProfit = propTrade.TakeProfit,
                    StopLoss = propTrade.StopLoss,
                    PropUserId = propUser.PropUserId,
                    PairName = Pair
                };

            // Use the context to add and save the new propTrade instance
            var context = dbContextFactory.CreateDbContext();

            var myT = await context.propUsers.Where(c => c.ApplicationUserId == user2)
              .FirstOrDefaultAsync();
            if (myT.Balance < propTrade.AmountForOrder)
            {
                ErrorMessage = "Not Allow Balance Greater";
                return;
            }
            myT.Balance -= propTrade.AmountForOrder;


            await context.propTrdaes.AddAsync(newPropTrade);
            await context.SaveChangesAsync();
            OrderTradeList = await ListOfOpenTrades();
            propUser = await GetPropUser(user2);
        }
    }

    private double GetPercentage(int level)
    {
        // Map the Level range (2-20) to 0-100% for the progress bar width.
        return (level - 2) / 18.0 * 100;
    }

    protected override async Task OnInitializedAsync()
    {
        editContext = new EditContext(propTrade);
        editContext.OnFieldChanged += HandleFieldChanged;
        // Fetch initial data
        var context = HttpContextAccessor.HttpContext;
        if (context != null)
        {
            var user5 = await UserAccessor.GetRequiredUserAsync(context);
            if (user5 != null)
            {
                //check here or incoming pair is valid in our format if not default BTCUSDT
                //TODO
                var conn = dbContextFactory.CreateDbContext();
                bool exists = await conn.prepPirs.AnyAsync(p => p.PairName == Pair);
                if (exists)
                {
                    //Its valid
                    user2 = user5.Id; // Get the user ID here
                    Console.WriteLine(user5.Id);
                    // PropUserId=await GetPropUserId(user2);
                    propUser = await GetPropUser(user2);
                    userIdprop = propUser.PropUserId;
                    //  PropUserId = propUser.PropUserId;
                    OrderTradeList = await ListOfOpenTrades();
                }
                else
                {
                    _manager.NavigateTo($"ErrorPrepPAir/{Pair}");
                }
            }
            else
            {
                ErrorMessage = "Unable to retrieve user.";
            }
        }
        else
        {
            ErrorMessage = "HttpContext is not available.";
        }

        // Set up a timer to refresh data every 5 seconds

    }
    /*This method need to moified later*/

    private async void HandleFieldChanged(object sender, FieldChangedEventArgs e)
    {
        if (e.FieldIdentifier.FieldName == nameof(propTrade.OrderPriceOpened))
        {
            //   await CalculateBuyMarketLiquidation(Level,50000, propTrade.OrderPriceOpened);
        }
    }

    public void Dispose()
    {
        // Dispose the timer when the component is disposed
        _timer?.Dispose();
    }

    [CascadingParameter(Name = "BtcPrice")]
    public string BtcPrice
    {
        get => btcPriceVariable;
        set
        {
            if (btcPriceVariable != value)
            {
                btcPriceVariable = value;
                // HandleAllCOmmand().ConfigureAwait(false);

                ListOfOrders().ConfigureAwait(false);


            }
        }
    }
    protected override void OnParametersSet()
    {
        btcPriceVariable = BtcPrice;

    }
    private async Task<List<PropTrade>> ListOfOpenTrades()
    {


        var btcDecimal = decimal.TryParse(btcPriceVariable, out var parsedPrice) ? parsedPrice : 0m;

        // Get the context
        var context = dbContextFactory.CreateDbContext();

        // Log the query execution to check if it's returning any results
        var myTrades = await context.propTrdaes
    .Where(c => c.PropUserId == userIdprop && (c.Status == OrderStatus.Open || c.Status == OrderStatus.Pending) && c.PairName == Pair)
            .ToListAsync();

        // Log the results to see what's coming back
        Console.WriteLine($"Number of trades found: {myTrades.Count}");

        // Return the list of trades
        return myTrades;
    }

    private decimal CalculateProfitLossInDollar(decimal orderPrice, decimal currentPrice, decimal amount, int leverage, OrderTypeProp ordertype, MarketType marketType, OrderStatus orderStatus)
    {
        if (orderStatus == OrderStatus.Pending)
        {
            return 0.0m;
        }

        // Calculate the effective amount based on leverage
        decimal effectiveAmount = (amount * leverage) / orderPrice;
        decimal leveragedProfitLoss = 0m;

        if (orderStatus == OrderStatus.Open && marketType == MarketType.Market || marketType == MarketType.Order)
        {
            if (ordertype == OrderTypeProp.Buy)
            {
                // For a long position
                if (currentPrice > orderPrice)
                {
                    // Profit calculation
                    leveragedProfitLoss = (currentPrice - orderPrice) * effectiveAmount;
                }
                else if (currentPrice < orderPrice)
                {
                    // Loss calculation
                    leveragedProfitLoss = (orderPrice - currentPrice) * effectiveAmount * -1; // Negative for loss
                }
            }
            else if (ordertype == OrderTypeProp.Sell)
            {
                // For a short position
                if (currentPrice < orderPrice)
                {
                    // Profit calculation
                    leveragedProfitLoss = (orderPrice - currentPrice) * effectiveAmount;
                }
                else if (currentPrice > orderPrice)
                {
                    // Loss calculation
                    leveragedProfitLoss = (currentPrice - orderPrice) * effectiveAmount * -1; // Negative for loss
                }
            }
        }

        // Return the profit or loss in the same currency as the asset (e.g., USD)
        return leveragedProfitLoss;
    }
    private async Task<PropUser> GetPropUser(string userId)
    {
        var context = dbContextFactory.CreateDbContext();
        var mydata = await context.propUsers
        .Where(c => c.ApplicationUserId == userId)
        .FirstOrDefaultAsync();
        return mydata;
    }
    private async Task HandleAllCOmmand()
    {
        //whole this checks are background task which later relocate to right section for now for tets i need here for eaciertest
        OrderTradeList = await ListOfOpenTrades();
        var btcDecimal = decimal.TryParse(btcPriceVariable, out var parsedPrice) ? parsedPrice : 0m;

        var context = dbContextFactory.CreateDbContext();
        var DatasToCHeck = await context.propTrdaes.Where(c => c.PropUserId == propUser.PropUserId && (c.Status == OrderStatus.Open || c.Status == OrderStatus.Pending) && c.PairName == Pair)
        .ToListAsync();
        var EditUserX = await context.propUsers.Where(c => c.ApplicationUserId == user2)
        .FirstOrDefaultAsync();
        if (btcDecimal == 0)
        {
            return;
        }
        foreach (var x in DatasToCHeck)
        {


            if (x.orderTypeProp == OrderTypeProp.Buy && x.MarketType == MarketType.Market)
            {
                var pnl = Math.Round(CalculateProfitLossInDollar(
                      x.OrderPriceOpened,
                      btcDecimal,
                      x.AmountForOrder,
                      x.Leverage, x.orderTypeProp, x.MarketType, x.Status
      ),
              1
                  );
                // Stop-loss activated if the price has hit or dropped below StopLoss
                if (btcDecimal <= x.StopLoss)
                {
                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.StopLoss;
                    x.TradeClosedDate = DateTime.Now;
                    x.ProfitInCase = pnl;

                    // Corrected addition to balance
                    EditUserX.Balance += (x.AmountForOrder - Math.Abs(pnl));

                    await context.SaveChangesAsync();
                    OrderTradeList = await ListOfOpenTrades();
                }
                if (btcDecimal >= x.TakeProfit)
                {


                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.TakeProfit;
                    x.TradeClosedDate = DateTime.Now;
                    x.ProfitInCase = pnl;

                    // Corrected addition to balance
                    EditUserX.Balance += (x.AmountForOrder + Math.Abs(pnl));

                    await context.SaveChangesAsync();
                    OrderTradeList = await ListOfOpenTrades();
                    propUser = await GetPropUser(user2);

                }
                var adjustedLiquidationPrice = x.LiquidationPrice * 1.001m; // Add 0.1%

                if (btcDecimal <= adjustedLiquidationPrice)
                {
                    x.OrderPriceClosed = adjustedLiquidationPrice; // Use the adjusted liquidation price
                    x.Status = OrderStatus.Liquidated;
                    x.ProfitInCase = pnl;

                    await context.SaveChangesAsync();
                }
                /*
                var liquidationPriceMaxRange = x.AmountForOrder;
                decimal liquidationPrice = x.OrderPriceOpened * (1 - 1 / Level);
                //liquidation max range is for example 50
                //if pnl is -50 trade liquidated
                if (pnl >= -liquidationPriceMaxRange)
                    {
                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.Liquidated;
                    await context.SaveChangesAsync();
            }
            */
            }
            if (x.orderTypeProp == OrderTypeProp.Sell && x.MarketType == MarketType.Market)
            {
                var pnl = Math.Round(CalculateProfitLossInDollar(
                       x.OrderPriceOpened,
                       btcDecimal,
                       x.AmountForOrder,
                       x.Leverage, x.orderTypeProp, x.MarketType, x.Status),
               1
                   );
                // Stop-loss activated if the price has hit or dropped below StopLoss
                if (btcDecimal >= x.StopLoss)
                {
                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.StopLoss;
                    x.TradeClosedDate = DateTime.Now;
                    x.ProfitInCase = pnl;

                    // Corrected addition to balance
                    EditUserX.Balance += (x.AmountForOrder - Math.Abs(pnl));

                    await context.SaveChangesAsync();
                    OrderTradeList = await ListOfOpenTrades();
                }
                if (btcDecimal <= x.TakeProfit)
                {
                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.TakeProfit;
                    x.TradeClosedDate = DateTime.Now;
                    x.ProfitInCase = pnl;

                    // Corrected addition to balance
                    EditUserX.Balance += (x.AmountForOrder + Math.Abs(pnl));

                    await context.SaveChangesAsync();
                    OrderTradeList = await ListOfOpenTrades();
                    propUser = await GetPropUser(user2);

                }
                var adjustedLiquidationPrice = x.LiquidationPrice * 0.999m;
                if (btcDecimal >= adjustedLiquidationPrice)
                {
                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.Liquidated;
                    x.ProfitInCase = pnl;

                    await context.SaveChangesAsync();
                }
                /*
                var liquidationPriceMaxRange = x.AmountForOrder;
                decimal liquidationPrice = x.OrderPriceOpened * (1 - 1 / Level);
                //liquidation max range is for example 50
                //if pnl is -50 trade liquidated
                if (pnl >= -liquidationPriceMaxRange)
                    {
                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.Liquidated;
                    await context.SaveChangesAsync();
            }
            */
            }
            decimal targetPrice = x.OrderPriceOpened; // The target price for opening/closing the order
            decimal priceRange = 1m; // $10 range

            // Check if it's a Buy order, in the correct market type, and in Pending status
            if (x.orderTypeProp == OrderTypeProp.Buy && x.MarketType == MarketType.Order && x.Status == OrderStatus.Pending)
            {
                // Open the order only if the price is within a $10 range of the target price
                if (btcDecimal >= targetPrice - priceRange && btcDecimal <= targetPrice + priceRange)
                {
                    x.Status = OrderStatus.Open;
                    x.OrderPriceTriggerd = btcDecimal;
                    x.OrderTriggerdAt = DateTime.Now;


                    await context.SaveChangesAsync();
                    Console.WriteLine($"Order opened at price: {btcDecimal}");
                }
                //RTODO second side if price under
                if (btcDecimal < targetPrice - priceRange)
                {

                    x.Status = OrderStatus.Open;
                    x.OrderPriceTriggerd = btcDecimal;
                    x.OrderTriggerdAt = DateTime.Now;
                    await context.SaveChangesAsync();
                }
            }
            if (x.orderTypeProp == OrderTypeProp.Sell && x.MarketType == MarketType.Order && x.Status == OrderStatus.Pending)
            {
                if (btcDecimal <= targetPrice - priceRange && btcDecimal >= targetPrice + priceRange)
                {
                    x.Status = OrderStatus.Open;
                    x.OrderPriceTriggerd = btcDecimal;
                    x.OrderTriggerdAt = DateTime.Now;


                    await context.SaveChangesAsync();
                    Console.WriteLine($"Order opened at price: {btcDecimal}");
                }
                //RTODO second side if price under
                if (btcDecimal < targetPrice - priceRange)
                {

                    x.Status = OrderStatus.Open;
                    x.OrderPriceTriggerd = btcDecimal;
                    x.OrderTriggerdAt = DateTime.Now;
                    await context.SaveChangesAsync();
                    Console.WriteLine($"Order closed due to low price: {btcDecimal}");
                }
            }

            if (x.orderTypeProp == OrderTypeProp.Buy && x.MarketType == MarketType.Order && x.Status == OrderStatus.Open)
            {
                var pnl = Math.Round(CalculateProfitLossInDollar(
    x.OrderPriceTriggerd ?? 0,
    btcDecimal,
                        x.AmountForOrder,
                        x.Leverage, x.orderTypeProp, x.MarketType, x.Status),
                1
                    );
                // Stop-loss activated if the price has hit or dropped below StopLoss
                if (btcDecimal <= x.StopLoss)
                {


                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.StopLoss;
                    x.TradeClosedDate = DateTime.Now;
                    x.ProfitInCase = pnl;
                    x.OrderPriceTriggerd = btcDecimal;
                    // Corrected addition to balance
                    EditUserX.Balance += (x.AmountForOrder - Math.Abs(pnl));

                    await context.SaveChangesAsync();
                    OrderTradeList = await ListOfOpenTrades();
                }
                if (btcDecimal >= x.TakeProfit)
                {


                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.TakeProfit;
                    x.TradeClosedDate = DateTime.Now;
                    x.ProfitInCase = pnl;

                    // Corrected addition to balance
                    EditUserX.Balance += (x.AmountForOrder + Math.Abs(pnl));

                    await context.SaveChangesAsync();
                    OrderTradeList = await ListOfOpenTrades();
                    propUser = await GetPropUser(user2);

                }
                var adjustedLiquidationPrice = x.LiquidationPrice * 1.001m; // Add 0.1%

                if (btcDecimal <= adjustedLiquidationPrice)
                {
                    x.OrderPriceClosed = adjustedLiquidationPrice; // Use the adjusted liquidation price
                    x.Status = OrderStatus.Liquidated;
                    x.ProfitInCase = pnl;

                    await context.SaveChangesAsync();
                }
                /*
                var liquidationPriceMaxRange = x.AmountForOrder;
                decimal liquidationPrice = x.OrderPriceOpened * (1 - 1 / Level);
                //liquidation max range is for example 50
                //if pnl is -50 trade liquidated
                if (pnl <= -liquidationPriceMaxRange)
                    {
                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.Liquidated;
                    await context.SaveChangesAsync();
            }
            */
            }
            if (x.orderTypeProp == OrderTypeProp.Sell && x.MarketType == MarketType.Order && x.Status == OrderStatus.Open)
            {
                var pnl = Math.Round(CalculateProfitLossInDollar(
       x.OrderPriceTriggerd ?? 0, btcDecimal,
                       x.AmountForOrder,
                       x.Leverage, x.orderTypeProp, x.MarketType, x.Status),
               1
                   );
                // Stop-loss activated if the price has hit or dropped below StopLoss
                if (btcDecimal >= x.StopLoss)
                {


                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.StopLoss;
                    x.TradeClosedDate = DateTime.Now;
                    x.ProfitInCase = pnl;
                    x.OrderPriceTriggerd = btcDecimal;

                    // Corrected addition to balance
                    EditUserX.Balance += (x.AmountForOrder - Math.Abs(pnl));

                    await context.SaveChangesAsync();
                    OrderTradeList = await ListOfOpenTrades();
                }
                if (btcDecimal <= x.TakeProfit)
                {

                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.TakeProfit;
                    x.TradeClosedDate = DateTime.Now;
                    x.ProfitInCase = pnl;

                    // Corrected addition to balance
                    EditUserX.Balance += (x.AmountForOrder + Math.Abs(pnl));

                    await context.SaveChangesAsync();
                    OrderTradeList = await ListOfOpenTrades();
                    propUser = await GetPropUser(user2);

                }
                var adjustedLiquidationPrice = x.LiquidationPrice * 0.999m;
                if (btcDecimal >= adjustedLiquidationPrice)
                {
                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.Liquidated;
                    x.ProfitInCase = pnl;

                    await context.SaveChangesAsync();
                }
                /*
                var liquidationPriceMaxRange = x.AmountForOrder;
                decimal liquidationPrice = x.OrderPriceOpened * (1 - 1 / Level);
                //liquidation max range is for example 50
                //if pnl is -50 trade liquidated
                if (pnl <= -liquidationPriceMaxRange)
                    {
                    x.OrderPriceClosed = btcDecimal;
                    x.Status = OrderStatus.Liquidated;
                    await context.SaveChangesAsync();
                }*/
            }


        }
    }
    private async Task CloseMarketOrder(int tradePoprdId)
    {
        //TODO Modified this method for closind order sel and buy
        var btcDecimal = decimal.TryParse(btcPriceVariable, out var parsedPrice) ? parsedPrice : 0m;
        var context = dbContextFactory.CreateDbContext();
        var Dataget = await context.propTrdaes.
        Where(c => c.PropTradeId == tradePoprdId).FirstOrDefaultAsync();

        var propuserI = await context.propUsers.
                     Where(c => c.PropUserId == userIdprop).FirstOrDefaultAsync();

        var pnl = Math.Round(CalculateProfitLossInDollar(
                          Dataget.OrderPriceOpened,
                           btcDecimal,
                          Dataget.AmountForOrder,
                          Dataget.Leverage, Dataget.orderTypeProp, Dataget.MarketType, Dataget.Status
           ),
                   1
                       );
        Console.WriteLine(pnl);
        //make this button dynamic for all orders TODO
    if (btcDecimal > Dataget.OrderPriceOpened)
        {
            propuserI.Balance += (pnl + Dataget.AmountForOrder);
            Dataget.ProfitInCase = pnl;
            Dataget.Status = OrderStatus.ClosedManually;
            Dataget.OrderPriceClosed = btcDecimal;
            Dataget.TradeClosedDate = DateTime.Now;
            await context.SaveChangesAsync();
            OrderTradeList = await ListOfOpenTrades();
            propUser = await GetPropUser(user2);
            Console.WriteLine(pnl);

        }
        if (btcDecimal <= Dataget.OrderPriceOpened)
        {
            propuserI.Balance += Dataget.AmountForOrder - Math.Abs(pnl);
            Dataget.ProfitInCase = pnl;
            Dataget.Status = OrderStatus.ClosedManually;
            Dataget.OrderPriceClosed = btcDecimal;
            Dataget.TradeClosedDate = DateTime.Now;
            await context.SaveChangesAsync();
            OrderTradeList = await ListOfOpenTrades();
            propUser = await GetPropUser(user2);
            Console.WriteLine(pnl);

        }
    }
    public static decimal CalculateLiquidationPrice(decimal entryPrice, decimal leverage, OrderTypeProp ordertype)
    {
        return ordertype switch
        {
            OrderTypeProp.Buy => entryPrice * (1 - (1 / leverage)),
            OrderTypeProp.Sell => entryPrice * (1 + (1 / leverage)),
            _ => throw new ArgumentException("Invalid order type.", nameof(ordertype))
        };

    }

    private async Task EditStopLossTakeProfitButton(int tradeId)
    {

        if (propTrade == null)
        {
            throw new InvalidOperationException("The 'propTrade' object cannot be null.");
        }


        var context = await dbContextFactory.CreateDbContextAsync();

        // Find the trade by tradeId
        var targetTrade = await context.propTrdaes
            .FirstOrDefaultAsync(c => c.PropTradeId == tradeId);


        if (propTrade.TakeProfit < 0)
        {
            ErrorMessage = "Take Profit cannot be negative.";
            // throw new ArgumentException("Take Profit cannot be negative.");
            return;
        }
        if (propTrade.StopLoss < 0)
        {
            ErrorMessage = "Stop Loss cannot be negative.";

            //  throw new ArgumentException("Stop Loss cannot be negative.");
            return;
        }
        // Update the properties directly on targetTrade
        targetTrade.TakeProfit = propTrade.TakeProfit;
        targetTrade.StopLoss = propTrade.StopLoss;
        targetTrade.Leverage = Level;
        targetTrade.PairName = Pair;

        // Reset or update additional properties if needed
        targetTrade.ProfitInCase = 0;
        targetTrade.FeeInCase = 0;

        // Save changes to the database
        await context.SaveChangesAsync();

        // Update UI elements if necessary
        EditSLTP = false;
        OrderTradeList = await ListOfOpenTrades();
        StateHasChanged();
    }

    private void ShowEditSPLForm()
    {
        EditSLTP = true; // Set to true to show the modal form
        StateHasChanged();  // Refresh UI

    }


    private void Close()
    {
        EditSLTP = false;
        //   StateHasChanged();  // Refresh UI
    }

    private async Task ListOfOrders()
    {
        OrderTradeList = await ListOfOpenTrades();

    }
}

